<?php

namespace app\models\core;

use app\components\templates\ModelTemplate;
use phpDocumentor\Reflection\Types\String_;
use Ramsey\Uuid\Uuid;
use Yii;

/**
 * Class Base
 * Base class for all data models.
 *
 * A data model object represents one record in the corresponding data table. Every access to the record in the data
 * tables is done via the model object. This way, it can be assured, that validators are checked, behaviors are executed,
 * etc.
 * For every data table, a base class (i.e. "base/BaseCoreCore.php") is generated by the template manager. This file should not
 * be modified, since it could be overridden by the template manager. It implements the labels for the columns,
 * rules (= validators), default values (in the "init()" method) and calculations (in a method "beforeSave()").
 * Additionally the template generate creates an mostly empty class (i.e. CoreCore.php) that extends the Base class above.
 * If you want to modify the data model manually, you should do it here.
 *
 * Together with the data model, a search class (an automatically generated version, i.e. "base/CoreCoreSearch.php) and
 * a mostly empty one (i.e. "CoreCoreSearch.php") for your modifications. These classes are used to find records based on query values.
 * The base search class uses a trait class "SearchModelTrait.php" that contains the methods that would otherwise identical in
 * every base search class.
 * If you want to modify how records of a data model can be search for, you should override some of the methods in the
 * the custom search model class (i.e. "CoreCoreSearch.php").
 *
 * @package app\models\base
 */
abstract class Base extends \yii\db\ActiveRecord
{

    /**
     * Name of the module (= table set) to which this data model belongs. For "ProjectExpedition" this would be "Project".
     */
    const MODULE = '';
    /**
     * Short name of the data model. For "ProjectExpedition" this would be "Expedition".
     */
    const SHORT_NAME = '';

    /**
     * Name of the column that identifies a record. This is not the (internal) id, but the name, that is also used in filters, etc.
     * For "ProjectExpedition", this would be the column "exp_acronym" which holds the name of the expedition, i.e. "DSEIS".
     */
    const NAME_ATTRIBUTE = '';

    /**
     * Name of the class of the data model which holds the parent records. For "CoreCore", this would be "ProjectHole"
     */
    const PARENT_CLASSNAME = '';

    /**
     * Associative array of the ancestor data models (parent relation hierarchy). Every element in the array is of the
     * form <short name> => <Class name>, i.e. ['hole' => 'ProjectHole', ...]
     */
    const ANCESTORS = [];

    /**
     * Associative array of columns and their default value.
     */
    const DEFAULT_VALUES = [];

    /**
     * @event Event an event that is triggered when calling defaults action.
     */
    const EVENT_DEFAULTS = 'defaults';

    /**
     * integer How many seconds may the SQL-Command to fetch a parent object be cached.
     */
    const PARENT_CACHE_DURATION = 600;

    const COMBINED_ID_FIELDS = ['combined_id', 'sample_combined_id', 'request_combined_id'];

    /**
     * Returns the full name (incl. namespace) of the model class
     * @return string
     */
    public static function getModelFullName() {
        return static::MODULE . static::SHORT_NAME;
        // return preg_replace("/app\\\\(models|forms)\\\\/", "", static::class);
    }

    public static function findAllModelClasses() {
        $classes = [];
        $matches = [];
        foreach (glob(\Yii::getAlias('@app/models/base') . '/*.php') as $filename) {
            if (!preg_match ("/Search\.php$/", $filename) && preg_match("/\\/Base([A-Z].+)\\.php$/", $filename, $matches)) {
                $classes[] = "app\\models\\" . $matches[1];
            }
        }
        return $classes;
    }

    private static $childModelClasses = [];

    public static function findChildModelClasses($modelName) {
        if (!isset (static::$childModelClasses[$modelName])) {
            static::$childModelClasses[$modelName] = ["\\app\\models\\ArchiveFile"];
            foreach (static::findAllModelClasses() as $class) {
                try {
                    $parentName = constant($class . "::PARENT_CLASSNAME");
                    if ($parentName == $modelName) {
                        static::$childModelClasses[$modelName][] = $class;
                    }
                }
                catch (\Exception $e){}
            }
        }

        return static::$childModelClasses[$modelName];
    }



    /**
     * Returns the model template
     * @return \app\components\templates\ModelTemplate|null
     */
    public function getModelTemplate() {
        $className = get_class($this);
        $name = substr($className, strrpos($className, '\\') + 1);
        return Yii::$app->templates->getModelTemplate($name);
    }

    /**
     * Returns all form templates for this model
     * @return \app\components\templates\FormTemplate[]
     */
    public function getFormTemplates() {
        return $this->getModelTemplate()->getFormTemplates();
    }


    public function rules()
    {
        $rules = [];
        if (static::NAME_ATTRIBUTE && \Yii::$app->params['validateNoUnderscoresInNameAttribute']) {
            $rules[] = [static::NAME_ATTRIBUTE, 'match', 'pattern' => '/_/', 'not' => true, 'message' => '{attribute} may not contain underscores'];
        }

        if (\Yii::$app && \Yii::$app->has('igsn')) {
            foreach ($this->behaviors as $behavior) {
                if ($behavior instanceof \app\behaviors\IgsnBehavior) {
                    $attribute = $behavior->igsnField;
                    if (strlen($this->{$attribute}) > 1) {
                        $rules[] = [$attribute, 'validateIgsn'];
                    }
                }
            }
        }

        return $rules;
    }

    /**
     * Checks, if the igsn number already exists for a different model
     * @param $attribute Name of the igsn column
     */
    public function validateIgsn($attribute) {
        $igsnNumber = $this->{$attribute};
        if (!\Yii::$app->igsn->validateIgsn($igsnNumber, $this)) {
            $this->addError($attribute, "IGSN '" . $igsnNumber . "' already exists.");
        }
    }

    /**
     * Returns the automatic behaviors, that are generated, if some attributes are present in the data model.
     * @return \yii\base\Behavior[] Array of behaviors
     */
    public function behaviors()
    {
        $behaviors = parent::behaviors();

        foreach (static::COMBINED_ID_FIELDS as $combinedIdField) {
            if ($this->hasAttribute($combinedIdField)) {
                $behaviors[] = [
                    'class' => \app\behaviors\CombinedIdBehavior::class,
                    'combinedIdField' => $combinedIdField
                ];
            }
        }


        if ($this->tableName() == 'curation_storage' && $this->hasAttribute('combined_id')) {
            $behaviors[] = [
                'class' => \app\behaviors\UpdateStorageCombinedIdBehavior::class
            ];
        }

        // TODO: Check for $app and module isgn should only be temporary until the igsn component can be used in tests
        if ($this->hasAttribute('igsn') && \Yii::$app && \Yii::$app->has('igsn')) {
            $defaultValue = isset(static::DEFAULT_VALUES['igsn']) ? static::DEFAULT_VALUES['igsn'] : null;
            if (!\Yii::$app->igsn->isObjectTagRequired() || ($defaultValue && $defaultValue > '' && strlen($defaultValue) == 1 && in_array($defaultValue, \app\components\Igsn::$IcdpObjectTags))) {
                $behaviors = array_merge($behaviors, [
                    'igsn' => [
                        'class' => \app\behaviors\IgsnBehavior::class,
                        'objectTag' => $defaultValue
                    ]
                ]);
            }
        }

        if ($this->hasAttribute('curator')) {
/*
            $behaviors[] = [
                'class' => \app\behaviors\CuratorBehavior::class
            ];
*/
        }

        if ($this->tableName() == 'curation_section_split') {
            $behaviors[] = [
                'class' => \app\behaviors\CurationSectionSplitCoreboxBehavior::class
            ];
        }

        return $behaviors;
    }

    public function transactions()
    {
        return [self::SCENARIO_DEFAULT => self::OP_INSERT];
    }


    /**
     * Can the current use delete records recursively
     * @return bool
     */
    public static function canDeleteRecursive() {
        return \Yii::$app->user->can('sa');
    }

    /**
     * Delete models recursively
     * @param $where
     * @throws \yii\db\Exception
     */
    public static function deleteAllRecursive($where) {
        $modelName = substr(get_called_class(), strrpos(get_called_class(), '\\') + 1);
        $modelTemplate = Yii::$app->templates->getModelTemplate($modelName);
        if ($modelTemplate) {
            if (static::find()->where($where)->exists()) {
                if (static::canDeleteRecursive()) {
                    foreach ($modelTemplate->getReferencingModelTemplates() as $refModelTemplate) {
                        foreach ($refModelTemplate->relations as $name => $fkey) {
                            if($fkey->relationType == 'nm') {
                                $whereInSqlFormat = $where[1] . ' IN ('.implode(',', $where[2]) .')';
                                if ($fkey->relatedTable) {
                                    $tableName = $fkey->oppositionRelation ? $fkey->relatedTable . "_" . $refModelTemplate->table : $refModelTemplate->table . "_" . $fkey->relatedTable;
                                    $sqlCommand = \Yii::$app->db->createCommand('DELETE FROM ' .$tableName.' WHERE '.$tableName.'.'.$refModelTemplate->table.'_id IN (SELECT id FROM '.$refModelTemplate->table.' WHERE ('.$whereInSqlFormat.'))');
                                    $sqlCommand->execute();
                                }
                            }
                            if ($fkey->foreignTable == $modelTemplate->table) {
                                $isSingleColumn = (sizeof($fkey->localColumns) == 1);
                                $conditions = ['OR'];
                                $ids = [];

                                $sql = static::find()->andWhere($where)->select($fkey->foreignColumns)->createCommand()->getRawSql();
                                foreach (\Yii::$app->db->createCommand($sql)->queryAll(\PDO::FETCH_NUM) as $foreignValues) {
                                    if ($isSingleColumn)
                                        $ids[] = $foreignValues[0];
                                    else {
                                        $condition = [];
                                        foreach ($fkey->localColumns as $i => $localColumn) {
                                            $condition[] = [$localColumn => $foreignValues[$i]];
                                        }
                                        $conditions[] = $condition;
                                    }
                                }
                                if ($isSingleColumn) $conditions = ['IN', $fkey->localColumns[0], $ids];

                                $refClass = $refModelTemplate->getCustomClass();
                                if (!class_exists($refClass)) {
                                    throw new \Exception (get_called_class() . "::deleteAllRecursive() Class '" . $refClass . "' does not exist.");
                                }
                                set_time_limit(90);
                                $refClass::deleteAllRecursive($conditions);
                            }
                        }
                    }
                    foreach ($modelTemplate->relations as $relation) {
                        if($relation->relationType == 'nm') {
                            if ($relation->relatedTable) {
                                if ($fkey->relatedTable) {
                                    $whereInSqlFormat = $where[1] . ' IN ('.implode(',', $where[2]) .')';
                                    $tableName = $relation->oppositionRelation ? $relation->relatedTable . "_" . $modelTemplate->table : $modelTemplate->table . "_" . $relation->relatedTable;
                                    $sqlCommand = $sqlCommand = \Yii::$app->db->createCommand('DELETE FROM ' .$tableName.' WHERE '.$tableName.'.'.$modelTemplate->table.'_id IN (SELECT id FROM '. $modelTemplate->table.' WHERE '.$whereInSqlFormat.')');
                                    $sqlCommand->execute();
                                }
                            }
                        }
                    }
                    static::deleteAll($where);
                }
                else {
                    throw new \Exception (get_called_class() . "::deleteAllRecursive() You may not delete models from " . $modelName . " recursively.");
                }
            }
        }
        else {
            throw new \Exception(get_called_class() . "::deleteAllRecursive() Template for model " . $modelName . " not found.");
        }
    }

    /**
     * Delete the current record and all records from other tables with foreign key relations to the current record
     * @throws \Throwable
     * @throws \yii\db\StaleObjectException
     */
    public function deleteRecursive() {
        $modelTemplate = $this->getModelTemplate();
        if ($modelTemplate) {
            foreach ($modelTemplate->getReferencingModelTemplates() as $refModelTemplate) {
                foreach ($refModelTemplate->relations as $name => $fkey) {
                    if ($fkey->foreignTable == $modelTemplate->table) {
                        $conditions = [];
                        foreach ($fkey->localColumns as $i => $localColumn) {
                            $conditions[] = [$localColumn => $this->{$fkey->foreignColumns[$i]}];
                        }
                        if (sizeof($conditions) == 1)
                            $conditions = $conditions[0];
                        else
                            $conditions = ['AND', $conditions];

                        $refClass = $refModelTemplate->getCustomClass();
                        if (class_exists($refClass)) {
                            set_time_limit(90);
                            if ($refClass::canDeleteRecursive()) {
                                foreach ($refClass::find()->andWhere($conditions)->batch() as $models) {
                                    foreach ($models as $model) {
                                        $model->deleteRecursive();
                                    }
                                }
                            }
                            else
                                $refClass::deleteAll($conditions);
                        }
                    }
                }
            }
        }
        parent::delete();
    }


    /**
     * Returns an empty string, if no errors exist or an unsorted list with every error as list item
     * @return string Errors as html unsorted list
     */
    public function getErrorsHtml() {
        $html = "";
        foreach ($this->getErrors() AS $attribute => $errors) {
            foreach ($errors AS $error) {
                $html .= "<li>" . $attribute . ": " . $error . "<li>";
            }
        }
        if ($html) $html = "<ul>" . $html . "</ul>";
        return $html;
    }

    /**
     * this methode will add | edit | delete the records of one to many attributes
     * @param $cClassName string
     * @param $cRemoteColumn string
     * @param $cResultColumn string
     * @param $aIDs array
     */
    protected function setRelatedIdsOneToMany($cClassName, $cRemoteColumn, $cResultColumn, $aIDs) {
        if (empty($aIDs)) $aIDs = [];
        $query = call_user_func([$cClassName, 'find']);

        $query->andWhere([$cResultColumn => $this->id]);

        foreach ($query->all() AS $oModel) {
            $oModel->{$cResultColumn} = null;
            if (!$oModel->save()) {
                $message = '';
                $errors = $oModel->getErrors();
                foreach ($errors as $error) {
                    foreach ($error as $key => $value) {
                        $message .= $value . " \n";
                    }
                }

                throw new \Exception ('Cannot save ' . $cClassName . ' with id: ' .$oModel->id . '- errors: ' . $message);
            }
        }

        foreach ($aIDs as $nRemoteID) {
            $oModel = call_user_func([$cClassName, 'find'])->andWhere([$cRemoteColumn => $nRemoteID])->one();
            $oModel->{$cResultColumn} = $this->id;
            if (!$oModel->save()) {
                $message = '';
                $errors = $oModel->getErrors();
                foreach ($errors as $error) {
                    foreach ($error as $key => $value) {
                        $message .= $value . " \n";
                    }
                }

                throw new \Exception ('Cannot save ' . $cClassName . ' with id: ' .$oModel->id . '- errors: ' . $message);
            }
        }
    }

    /**
     * this methode will return the array of ids of the one to many attributes
     * @param $cRelationName string
     * @return array
     */
    protected function getRelatedIdsOnetoMany ($cRelationName) {
        $data = [];
        foreach ($this->{$cRelationName} AS $oModel) {
            $data[] = $oModel->id;
        }
        return $data;
    }

    /**
     * this methode will return the array of ids of the many to many attributes
     * @param $cClassName string
     * @param $aForeignKeys array
     * @param $cRelationName string
     * @return array
     */
    protected function getRelatedIds ($cClassName, $aForeignKeys, $cRelationName) {
        $data = [];
        $query = call_user_func([$cClassName, 'find']);
        foreach ($aForeignKeys AS $cRemoteColumn => $cLocalColumn) {
            $query->andWhere([$cRemoteColumn => $this->{$cLocalColumn}]);
        }
        foreach ($query->all() AS $oModel) {
            $data[] = $oModel->{$cRelationName}->id;
        }
        return $data;
    }

    /**
     * this methode will add | edit | delete the records of many to many attributes
     * @param $cClassName
     * @param $aForeignKeys
     * @param $cResultColumn
     * @param $aIDs
     */
    protected function setRelatedIds ($cClassName, $aForeignKeys, $cResultColumn, $aIDs) {
        if (empty($aIDs)) $aIDs = [];
        $query = call_user_func([$cClassName, 'find']);
        foreach ($aForeignKeys AS $cRemoteColumn => $cLocalColumn) {
            $query->andWhere([$cRemoteColumn => $this->{$cLocalColumn}]);
        }
        foreach ($query->all() AS $oModel) {
            $nRemoteID = $oModel->{$cResultColumn};
            $i = array_search ($nRemoteID, $aIDs, false);
            if ($i === false) {
                $oModel->delete();
            }
            else {
                array_splice ($aIDs, $i, 1);
            }
        }

        foreach ($aIDs as $nRemoteID) {
            $oModel = new $cClassName;
            foreach ($aForeignKeys AS $cRemoteColumn => $cLocalColumn) {
                $oModel->{$cRemoteColumn} = $this->{$cLocalColumn};
            }
            $oModel->{$cResultColumn} = $nRemoteID;
            if (!$oModel->save()) {
                throw new \Exception ('Cannot save new ' . $cClassName);
            }
        }
    }

    /**
     * This methode will generate unique uuid v5 based on uuidNameSpace, and the next string:
     * id:$modelID,modelClass:$classname
     * @param $model ModelTemplate
     * @return \Ramsey\Uuid\UuidInterface
     */
    private function generateUuid($model)
    {
        $uuid = Uuid::uuid5(\Yii::$app->params["uuidNameSpace"], 'id:'.$model->id . ',modelClass:'. get_class($model));
        return $uuid;
    }

    /**
     * This methode will inject the uuid in the target model
     * the uuid will be generated by generateUuid()
     * if the model is already sent once then only the uuid will be returned
     * @param $data ModelTemplate | ModelTemplate[] | string
     * @return ModelTemplate | ModelTemplate[]
     */
    public function injectUuid($data) {
        if($data) {
            $out = [];
            if(is_array($data)) {
                foreach ($data as $model) {
                    $out[] = $this->_injectUuid($model);
                }
                return $out;
            } else {
                return $this->_injectUuid($data);
            }
        }

    }

    /**
     * @param $model ModelTemplate
     * @return ModelTemplate | String
     */
    protected function _injectUuid($model) {
        $uuid = $this->generateUuid($model);
        $session = \Yii::$app->session;
        $uuidsInSession = $session->get('uuids');

        if(in_array($uuid, $uuidsInSession)) {
            return $uuid->toString();
        } else {
            $uuidsInSession[] = $uuid->toString();
            $session['uuids'] = $uuidsInSession;
            //$session->set('uuids', $uuidsInSession);
        }

        $pseudoColumns = $this->getPseudoColumns($model);
        $pseudoColumnsValues = [];
        foreach ($pseudoColumns as $pseudoColumn) {
            $pseudoColumnsValues[$pseudoColumn] = call_user_func([$model, 'get'.ucfirst($pseudoColumn)]);
        }
        $attributes = $model->attributes;
        $attributes = array_merge($pseudoColumnsValues, $attributes);

        return array_merge(['@uuid' => $uuid->toString()], $attributes);
    }

    public function getPseudoColumns($model) {
        $modelTemplate = $model->getModelTemplate();
        $result = [];
        $pseudoColumns = array_filter($modelTemplate->columns, function ($c) { return $c->type == 'pseudo'; });
        foreach ($pseudoColumns as $pseudoColumn) {
            $result[] = $pseudoColumn->name;
        }
        return $result;
    }

    /**
     * Use the parent combinedId value to generate the combinedId for this object
     * Usually the value of the NAME_ATTRIBUTE column is added after an "_".
     * @param string $combinedIdField Name of the combined id column for which the value is calculated
     * @return mixed|string The generated combinedId
     */
    public function calculateCombinedId ($combinedIdField = "combined_id") {
        $combinedId = $this->getParentCombinedId($combinedIdField);
        $attribute = $this::NAME_ATTRIBUTE;
        if ($attribute > "") {
            $combinedId .= ($combinedId > "" ? '_' : "") . $this->owner->{$attribute};
        }
        return $combinedId;
    }

    /**
     * Get the combined id of the parent object to fill the column in $combinedIdField
     * @param string $combinedIdField Name of the combined id column for which the value is calculated
     * @return string Value of the parent combined id (Empty string if no parent exists)
     */
    public function getParentCombinedId ($combinedIdField = "combined_id") {
        $parent = $this->parent;
        $parentCombinedId = "";
        if ($parent) {
            if ($parent->hasAttribute($combinedIdField))
                $parentCombinedId = "" . $parent->{$combinedIdField};
            else {
                $attribute = $parent::NAME_ATTRIBUTE;
                $parentCombinedId = "" . $parent->{$attribute};
            }
        }
        return $parentCombinedId;
    }
    
    /**
    * This method can be applied to all models that contain section units, i.e. a continuous sequence of units along the drill core.
    * The model requires a "top" attribute in [cm]. It calculates the length of a unit until the top of the next unit or to the section
    * end in case the unit is the lowermost on the section. 
    */

    public function getUnitLength()
    {
        $arrayUnits = $this->parent->geologyLithologies;
        $arrayUnitTops = [];
        foreach ($arrayUnits as $arrayUnit) {
            $arrayUnitTops[] = $arrayUnit->top;
        }
        sort($arrayUnitTops);
        $thisKey = array_search($this->top, $arrayUnitTops);
        $count = count($arrayUnitTops);
        if ($thisKey == ($count - 1)) {
            $unitLength = round($this->parent->curated_length - $this->top, 2);
        } else {
            $unitLength = round($arrayUnitTops[$thisKey + 1] - $this->top, 2);
        }
        return $unitLength;
    }

}
